#' Define 10x clonotypes
#'
#' Takes a list of paired chains and defines clonotypes.
#'
#' @param list.pairs List. List of cells generated by tenx.
#' @param clonality_input Named vector. Changes the parameters of clonality function.
#' @param cell Character. Possible values: `B` Bcells, `T` Tcells, `Tgd` Tcells GamaDelta.
#' @export
#'
#'
assigntenx <- function(list.pairs = list.pairs,
                       method = method,
                       clonality_input = clonality_input,
                       cell = cell,
                       col_res = col_res,
                       add_columns = add_columns){


  #Define classes to be used or discard

  if(method == "unique_all"){
    classes <- names(list.pairs)
    classes <- classes[!grepl("None", classes)]
  } else{
    classes.list    <- switch(method,
                              unique_paired = chain_classes$unique_paired,
                              sticky_ends = chain_classes$sticky_ends)

    classes         <- switch(cell, "B"   = classes.list$BigCell.classes,
                                    "T"   = classes.list$TabCell.classes,
                                    "Tgd" = classes.list$TgdCell.classes)
  }

  cdr3.match <- switch(cell, "B" = "cdr3_IG", "T" = "cdr3_TR", "Tgd" = "cdr3_TR")

  # Tabulate all detected chain classes and report the stats

  class_counts <- data.frame(
    ChainClass = names(list.pairs),
    Count = unlist(lapply(list.pairs, length)),
    stringsAsFactors = FALSE) %>%
    dplyr::arrange(nchar(ChainClass), ChainClass)

  class_counts <- as_tibble(class_counts)

  # Identify which will be kept or dropped

  class_counts$Status <- ifelse(class_counts$ChainClass %in% classes, "Kept", "Dropped")

  # Print summary

  summary_table <- class_counts %>%
    dplyr::group_by(Status) %>%
    dplyr::summarise(
      Classes = dplyr::n(),
      Cells = sum(Count),
      .groups = "drop"
    )

  message("Summary of chain class filtering:")
  print(summary_table)

  if ("Dropped" %in% class_counts$Status) {
    message("Dropped chain classes:")
    print(subset(class_counts, Status == "Dropped"))
  }


  # Now do the actual filtering, only selected classes move downstream
  list.pairs_filt <- list.pairs[names(list.pairs) %in% classes]

  # Concatenate each element of the list into a list of lists
  # Transform it into a data frame with 1 cell per row

  res <- do.call(c, list.pairs_filt)
  res <- lapply(res, FUN = row1, add_columns)
  res <- bind_rows(res, .id = "classes")

  #Extract chain
  res$classes <- gsub("\\..*", "", res$classes)

  #Coalesces raw_clonotype and barcode columns for each chain/cell
  res <- res %>% mutate_at(vars(matches("raw")), as.character) %>% mutate(sc.raw_clonotypes = coalesce(!!!select(., matches("raw"))))
  res <- res %>% mutate_at(vars(matches("bar")), as.character) %>% mutate(sc.barcodes = coalesce(!!!select(., matches("bar"))))

  #Removes individual.chain columns
  res <- res %>% select(-contains("raw_clonotype_id"))
  res <- res %>% select(-contains("barcode_"))

  #Function to remove columns with all rows = NA
  all_na <- function(x) any(!is.na(x))

  classes.keep <- names(table(res$classes))[table(res$classes) > 1]
  res <- res %>% filter(classes %in% classes.keep)

  #Apply this procedures to each class separately
  for (i in unique(res$classes)) {

    res.sub <- res %>% filter(classes == i)
    barcodes <- res.sub$sc.barcodes
    raw_clonotypes <- res.sub$sc.raw_clonotypes

    #Order columns alphabetically and remove all NA rows
    res.sub <- res.sub[,order(colnames(res.sub))]
    res.sub <- res.sub %>% select_if(all_na)


    #Concatenate all V-genes
    v_gene <- extract_and_unite(df = res.sub, column_name = "v_gene")
    #All V-genes separated
    v_genes_unique <- extract_and_unite(df = res.sub, column_name = "v_gene", unite = FALSE)
    #Concatenate all J-genes
    j_gene <- extract_and_unite(df = res.sub, column_name = "j_gene")
    #All J-genes separated
    j_genes_unique <- extract_and_unite(df = res.sub, column_name = "j_gene", unite = FALSE)
    #Concatenate all C-genes
    c_gene <- extract_and_unite(df = res.sub, column_name = "c_gene")
    #Concatenate all CDR3 nt
    cdr3_col <- extract_and_unite(df = res.sub, column_name = "cdr3_nt")
    #All CDR3 nt separated
    cdr3_col_unique <- extract_and_unite(df = res.sub, column_name = "cdr3_nt", unite = FALSE)
    #Concatenate all CDR3 aa
    cdr3_col2 <- extract_and_unite(df = res.sub, column_name = cdr3.match)
    #All CDR3 aa separated
    cdr3_col2_unique <- extract_and_unite(df = res.sub, column_name = cdr3.match, unite = FALSE)

    #Concatenate CDR3 nt length
    cdr3_length <- cdr3_col_unique %>%
      dplyr::mutate(across(everything(), nchar)) %>%
      tidyr::unite("cdr3_length", sep = "_") %>%
      dplyr::pull(cdr3_length)

    #Selected columns
    if(!is.null(add_columns)){
      selected_mat <- matrix(nrow = nrow(res.sub), ncol = length(add_columns))
      colnames(selected_mat) <- add_columns
      selected_mat <- as.data.frame(selected_mat)
      for(f in add_columns){
        selected <- as.data.frame(res.sub %>% ungroup() %>% select(starts_with(f))) %>% tidyr::unite(col = "col", sep = ";") %>% pull(col)
        selected_mat[,f] <- selected
      }

    }else{
      selected_mat <- NA
    }


    #Create final metadata table
    df.full <- data.frame(barcodes = barcodes,
                          v_genes = v_gene,
                          v_genes_unique,
                          j_genes = j_gene,
                          c_genes = c_gene,
                          j_genes_unique,
                          CDR3 = cdr3_col,
                          cdr3_col_unique,
                          cdr3_col2 = cdr3_col2,
                          cdr3_col2_unique,
                          cdr3_length = cdr3_length,
                          raw_clonotypes = raw_clonotypes,
                          selected = selected_mat)

    df.reduced <- data.frame(barcodes = barcodes,
                             v_genes = v_gene,
                             j_genes = j_gene,
                             CDR3 = cdr3_col,
                             cdr3_col2 = cdr3_col2,
                             cdr3_length = cdr3_length,
                             raw_clonotypes = raw_clonotypes)

    if(all(is.na(df.full$selected))){
      df.full$selected <- NULL
    }

    # Define default clonality parameters
    default_clonality_args <- list(
      output = "Clonal.output.10x",
      vgene_col = "v_genes",
      jgene_col = "j_genes",
      cdr3_col = "CDR3",
      cell = "T",
      output_original = TRUE,
      ident_col = "barcodes",
      mismatch = 0,
      suffix = i
    )

    # Merge with user input (if any)
    clonality_args <- modifyList(default_clonality_args, as.list(clonality_input))

    # Append suffix to output name
    clonality_args$output <- paste0(clonality_args$output, i)

    # Construct full or reduced metadata frame
    df1 <- switch(
      col_res,
      "full" = df.full,
      "reduced" = df.reduced
    )

    # Fix semicolon separation if present
    df1$v_genes <- gsub("\\+", ";", df1$v_genes)
    df1$j_genes <- gsub("\\+", ";", df1$j_genes)

    # Call clonality() using do.call for cleaner parameter passing
    do.call(clonality, c(list(data = df1), clonality_args))
  }
}
