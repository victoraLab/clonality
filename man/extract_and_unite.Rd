% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/extract_and_unite.R
\name{extract_and_unite}
\alias{extract_and_unite}
\title{Extract and Optionally Concatenate Columns by Pattern}
\usage{
extract_and_unite(df, column_name, unite = TRUE, use_regex = FALSE)
}
\arguments{
\item{df}{A data frame containing chain-specific columns (e.g. \code{v_gene_IGH}, \code{cdr3_nt_IGK}, etc.).}

\item{column_name}{A string pattern. If \code{use_regex = FALSE}, it is treated as a prefix passed to \code{startsWith()}.
If \code{use_regex = TRUE}, it is treated as a regular expression passed to \code{str_detect()}.}

\item{unite}{Logical. If \code{TRUE} (default), the matched columns are collapsed row-wise with \verb{_} as separator.
If \code{FALSE}, the matched columns are returned as-is in a tibble.}

\item{use_regex}{Logical. If \code{TRUE}, treats \code{column_name} as a regular expression for column matching.
Default is \code{FALSE}, for prefix-based selection.}
}
\value{
If \code{unite = TRUE}, returns a character vector of concatenated values per row.
If \code{unite = FALSE}, returns a tibble with the matched columns.
If no columns match, a warning is issued and either \code{character(0)} or an empty tibble is returned.
}
\description{
Selects columns from a data frame that match a given prefix or regular expression,
and optionally concatenates them into a single character vector per row.
}
\details{
This function is useful for collapsing multi-chain columns (e.g. \code{v_gene_IGH}, \code{v_gene_IGK})
into a unified column (e.g. \code{"IGH_IGK"}), or simply extracting subsets of columns for downstream processing.
}
\examples{
df <- tibble::tibble(
  v_gene_1 = c("V1", "V2"),
  v_gene_2 = c("V3", "V4"),
  other = c("x", "y")
)

# Concatenate v_gene columns into a single vector
extract_and_unite(df, "v_gene", unite = TRUE)

# Extract v_gene columns as a tibble
extract_and_unite(df, "v_gene", unite = FALSE)

# Use regex to match any column with "gene" in the name
extract_and_unite(df, "gene", unite = TRUE, use_regex = TRUE)

}
